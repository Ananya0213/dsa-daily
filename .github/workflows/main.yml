name: Daily DSA Problem

on:
  schedule:
    # Runs every day at 9 AM IST (3:30 AM UTC)
    - cron: '30 3 * * *'
  workflow_dispatch: # Allows manual trigger

jobs:
  solve-dsa:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Generate DSA problem solution
        run: |
          python3 << 'EOF'
          import os
          import datetime
          
          # DSA problems pool
          problems = [
              {
                  "name": "Two Sum",
                  "code": '''def two_sum(nums, target):
      """
      Find two numbers that add up to target.
      Time: O(n), Space: O(n)
      """
      seen = {}
      for i, num in enumerate(nums):
          complement = target - num
          if complement in seen:
              return [seen[complement], i]
          seen[num] = i
      return []

# Test
print(two_sum([2, 7, 11, 15], 9))  # [0, 1]'''
              },
              {
                  "name": "Reverse Linked List",
                  "code": '''class ListNode:
      def __init__(self, val=0, next=None):
          self.val = val
          self.next = next

def reverse_list(head):
      """
      Reverse a singly linked list.
      Time: O(n), Space: O(1)
      """
      prev = None
      curr = head
      while curr:
          next_temp = curr.next
          curr.next = prev
          prev = curr
          curr = next_temp
      return prev'''
              },
              {
                  "name": "Valid Palindrome",
                  "code": '''def is_palindrome(s):
      """
      Check if string is a palindrome (alphanumeric only).
      Time: O(n), Space: O(1)
      """
      left, right = 0, len(s) - 1
      while left < right:
          while left < right and not s[left].isalnum():
              left += 1
          while left < right and not s[right].isalnum():
              right -= 1
          if s[left].lower() != s[right].lower():
              return False
          left += 1
          right -= 1
      return True

# Test
print(is_palindrome("A man, a plan, a canal: Panama"))  # True'''
              },
              {
                  "name": "Binary Search",
                  "code": '''def binary_search(nums, target):
      """
      Binary search in sorted array.
      Time: O(log n), Space: O(1)
      """
      left, right = 0, len(nums) - 1
      while left <= right:
          mid = (left + right) // 2
          if nums[mid] == target:
              return mid
          elif nums[mid] < target:
              left = mid + 1
          else:
              right = mid - 1
      return -1

# Test
print(binary_search([1, 2, 3, 4, 5], 3))  # 2'''
              },
              {
                  "name": "Maximum Subarray",
                  "code": '''def max_subarray(nums):
      """
      Find maximum sum of contiguous subarray (Kadane's Algorithm).
      Time: O(n), Space: O(1)
      """
      max_sum = current_sum = nums[0]
      for num in nums[1:]:
          current_sum = max(num, current_sum + num)
          max_sum = max(max_sum, current_sum)
      return max_sum

# Test
print(max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 6'''
              },
              {
                  "name": "Merge Two Sorted Lists",
                  "code": '''class ListNode:
      def __init__(self, val=0, next=None):
          self.val = val
          self.next = next

def merge_two_lists(l1, l2):
      """
      Merge two sorted linked lists.
      Time: O(n+m), Space: O(1)
      """
      dummy = ListNode()
      current = dummy
      
      while l1 and l2:
          if l1.val <= l2.val:
              current.next = l1
              l1 = l1.next
          else:
              current.next = l2
              l2 = l2.next
          current = current.next
      
      current.next = l1 or l2
      return dummy.next'''
              },
              {
                  "name": "Valid Parentheses",
                  "code": '''def is_valid(s):
      """
      Check if parentheses are valid.
      Time: O(n), Space: O(n)
      """
      stack = []
      mapping = {')': '(', '}': '{', ']': '['}
      
      for char in s:
          if char in mapping:
              top = stack.pop() if stack else '#'
              if mapping[char] != top:
                  return False
          else:
              stack.append(char)
      
      return not stack

# Test
print(is_valid("()"))  # True
print(is_valid("()[]{}"))  # True'''
              },
              {
                  "name": "Climbing Stairs",
                  "code": '''def climb_stairs(n):
      """
      Count ways to climb n stairs (1 or 2 steps at a time).
      Time: O(n), Space: O(1)
      """
      if n <= 2:
          return n
      
      prev, curr = 1, 2
      for i in range(3, n + 1):
          prev, curr = curr, prev + curr
      return curr

# Test
print(climb_stairs(5))  # 8'''
              },
              {
                  "name": "Best Time to Buy and Sell Stock",
                  "code": '''def max_profit(prices):
      """
      Find maximum profit from buying and selling stock once.
      Time: O(n), Space: O(1)
      """
      if not prices:
          return 0
      
      min_price = prices[0]
      max_profit = 0
      
      for price in prices:
          min_price = min(min_price, price)
          max_profit = max(max_profit, price - min_price)
      
      return max_profit

# Test
print(max_profit([7, 1, 5, 3, 6, 4]))  # 5'''
              },
              {
                  "name": "Longest Common Prefix",
                  "code": '''def longest_common_prefix(strs):
      """
      Find longest common prefix among strings.
      Time: O(S) where S is sum of all characters, Space: O(1)
      """
      if not strs:
          return ""
      
      prefix = strs[0]
      for s in strs[1:]:
          while not s.startswith(prefix):
              prefix = prefix[:-1]
              if not prefix:
                  return ""
      return prefix

# Test
print(longest_common_prefix(["flower", "flow", "flight"]))  # "fl"'''
              }
          ]
          
          # Get day number (0-9 for 10 days cycle)
          start_date = datetime.date(2025, 12, 12)
          today = datetime.date.today()
          day_num = (today - start_date).days % len(problems)
          
          problem = problems[day_num]
          
          # Create directory structure
          os.makedirs('solutions', exist_ok=True)
          
          # Create solution file
          filename = f"solutions/day_{day_num + 1}_{problem['name'].lower().replace(' ', '_')}.py"
          
          with open(filename, 'w') as f:
              f.write(f"# Day {day_num + 1}: {problem['name']}\n")
              f.write(f"# Date: {today.strftime('%Y-%m-%d')}\n\n")
              f.write(problem['code'])
          
          print(f"Created: {filename}")
          print(f"Problem: {problem['name']}")
          EOF
          
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add .
          git commit -m "Daily DSA: $(date +'%Y-%m-%d') - Auto-generated solution" || echo "No changes to commit"
          git push
